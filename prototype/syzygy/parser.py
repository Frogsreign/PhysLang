import interpreter
from token import *
from tokentype import *
from statement import *
from expression import *

class Parser(object):
    # Takes in a list of tokens generated by scanner.py's Scanner
    def __init__(self, tokens):
        self.tokens = tokens
        self.current = 0
        self.statements = []

    # Returns a list of statements processed for interpretation
    def parse(self):
        while not self.atEnd():
            statement = self.declaration()
            self.statements.append(statement)
        return self.statements
    

    # Statement management functions

    def declaration(self):
        # if self.match(VAR): return self.variableDeclaration()
        # else: 
        return self.statement()

    def statement(self):
        if self.match(POINT): return self.pointStatement()
        else: # Catch bad format
            raise Exception("Unexpected command.")
        # elif self.match(FORCE): return self.forceStatement()
        # elif self.match(UPDATE): return self.updateStatement()

    def pointStatement(self):
        # Attributes of points that can receive expressions
        pos = None
        vel = None
        acc = None
        m = None
        e = None

        self.consume(LEFT_PAREN, 'Expected \'(\' after \'point\'.')
        self.consume(POS, 'Expected \'pos=\' as first argument of point.')
        self.consume(ASSIGN, 'Expected \'pos=\' as first argument of point.')
        pos = self.expression()
        while self.match(COMMA):
            if self.match(E):
                self.consume(ASSIGN, 'Expected \'=\' for parameter assignment.')
                e = self.expression()
            elif self.match(M):
                self.consume(ASSIGN, 'Expected \'=\' for parameter assignment.')
                m = self.expression()
            elif self.match(VEL):
                self.consume(ASSIGN, 'Expected \'=\' for parameter assignment.')
                vel = self.expression()
            elif self.match(ACC):
                self.consume(ASSIGN, 'Expected \'=\' for parameter assignment.')
                acc = self.expression()
            else: raise Exception('Unexpected parameter for point.')
                
        self.consume(RIGHT_PAREN, 'Expected \')\' to close point(pos=).')
        return PointStatement(pos, vel=vel, acc=acc, m=m, e=e)

    # Expression management functions
    # Check for commas, terms, factors, unaries, primaries (bracket expressions mostly), and numbers/strings, in this order

    # Base tree; has an indicator (bracket) for if working with parameters
    def expression(self, bracket=False):
        if bracket: return self.comma()
        return self.term()
    
    # Handles comma separated parameters/vector components
    def comma(self):
        expression = self.term()
        while self.match(COMMA):
            right = self.term()
            expression = CommaExpression(expression, right)
        return expression

    # Handles addition and subtraction terms
    def term(self):
        expression = self.factor() # next down the chain
        while self.match(MINUS) or self.match(PLUS):
            operator = self.previous()
            right = self.factor()
            expression = BinaryExpression(expression, operator, right)
        return expression

    # Handles multiplication and division terms
    def factor(self):
        expression = self.unary()
        while self.match(DIVIDE) or self.match(MULTIPLY):
            operator = self.previous()
            right = self.unary()
            expression = BinaryExpression(expression, operator, right)

        return expression
    
    # Just for negative numbers
    def unary(self):
        if self.match(MINUS):
            operator = self.previous()
            right = self.unary()
            return UnaryExpression(operator, right)
        return self.primary()
    
    # Basic units (numbers, parentheses, etc.)
    def primary(self):
        
        # if self.match(IDENTIFIER) -> would need variable expression handling
        # if self.match(TRUE/FALSE/NONE) -> would just be literals

        if self.match(NUMBER) or self.match(STRING):
            print(self.previous().literal)
            return LiteralExpression(self.previous().literal)
        
        if self.match(LEFT_PAREN):
            expression = self.expression()
            self.consume(RIGHT_PAREN, 'Expected \')\' to close expression.')
            return ParenthesesExpression(expression)
        
        if self.match(LEFT_BRACK):
            expression = self.expression(True)
            self.consume(RIGHT_BRACK, 'Expected \']\' to close expression.')
            return BracketExpression(expression)
        
        raise Exception('Expected expression.')

    # Helper functions
    # Checks if the current token is a specific type and proceeds if true
    def match(self, type):
        if self.atEnd() and type != EOF: return False
        if self.tokens[self.current].type == type:
            print(f"{self.current}: {type}")
            self.current += 1
            return True
        else: return False

    # Checks if the current token is a specific type and proceeds if true, but throws an error if false
    def consume(self, type, message='Syntax error.'):
        if self.atEnd() and type != EOF: return False
        if self.tokens[self.current].type == type:
            print(f"{self.current}: {type}")
            self.current += 1
        else: raise Exception(message)

    # Are we at the last token?
    def atEnd(self):
        return self.peek().type == EOF
    
    # What is the current token?
    def peek(self):
        return self.tokens[self.current]
    
    # What is the previous token?
    def previous(self):
        if self.current == 0: return None
        else: return self.tokens[self.current - 1]
    
    # Step forward and return the token that we just left (may not use this much in this form)
    def advance(self):
        if not self.atEnd(): self.current += 1
        return self.previous()
    